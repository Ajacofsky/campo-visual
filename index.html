import streamlit as st
import numpy as np
import cv2

st.set_page_config(layout="wide")
st.title("丘뒲잺 Calibraci칩n de P칤xeles - Rojo Absoluto")

file = st.sidebar.file_uploader("Subir Informe", type=['jpg', 'png', 'jpeg'])

if file:
    # 1. CARGA DE IMAGEN
    file_bytes = np.asarray(bytearray(file.read()), dtype=np.uint8)
    img = cv2.imdecode(file_bytes, 1)
    h, w = img.shape[:2]

    # 2. CONTROLES DE PRECISI칍N
    st.sidebar.header("游꿢 Ajustes")
    cx = st.sidebar.slider("Centro X", 0, w, w // 2)
    cy = st.sidebar.slider("Centro Y", 0, h, h // 2)
    
    # Este slider define el 60춿
    x60 = st.sidebar.slider("Alinear con Marca 60춿", cx, w, cx + 200)
    
    # EQUIDISTANCIA MATEM츼TICA
    dist_total = float(x60 - cx)
    paso = dist_total / 6.0

    # 3. MODIFICACI칍N DE LA MATRIZ (Pintar Rojo sobre los p칤xeles)
    # Creamos una copia para no da침ar la original
    canvas = img.copy()
    rojo_neon = [0, 0, 255]  # BGR para Rojo Puro en OpenCV

    # Dibujamos los 6 anillos equidistantes
    for i in range(1, 7):
        radio = int(i * paso)
        # Dibujamos el c칤rculo directamente en la matriz de la imagen
        # Grosor 5 para m치xima visibilidad
        cv2.circle(canvas, (cx, cy), radio, rojo_neon, 5)
        
        # Ponemos el texto de los grados
        cv2.putText(canvas, f"{i*10} deg", (cx + radio + 5, cy - 10), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, rojo_neon, 2)

    # Ejes Cartesianos
    cv2.line(canvas, (cx, 0), (cx, h), rojo_neon, 2)
    cv2.line(canvas, (0, cy), (w, cy), rojo_neon, 2)

    # 4. CONVERSI칍N FINAL PARA STREAMLIT
    # Pasamos de BGR (OpenCV) a RGB (Streamlit/Web)
    img_final = cv2.cvtColor(canvas, cv2.COLOR_BGR2RGB)
    
    st.image(img_final, use_container_width=True)
    
    st.sidebar.success(f"Configuraci칩n aplicada: {round(paso, 1)} px por cada 10춿")

else:
    st.info("Sub칤 la imagen para forzar el renderizado en rojo.")
