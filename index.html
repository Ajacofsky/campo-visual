import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

st.set_page_config(layout="wide", page_title="Peritaje Pro - CalibraciÃ³n Forzada")

# --- INICIALIZACIÃ“N DE ESTADO ---
if "puntos" not in st.session_state:
    st.session_state.puntos = []

def reiniciar():
    st.session_state.puntos = []

# --- INTERFAZ LATERAL ---
img_file = st.sidebar.file_uploader("ğŸ“ Subir Campo Visual", type=['jpg', 'png', 'jpeg'])
st.sidebar.button("ğŸ”„ Reiniciar CalibraciÃ³n", on_click=reiniciar)

if img_file is not None:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    
    n_puntos = len(st.session_state.puntos)

    # --- TEXTO GUÃA DINÃMICO (FORZADO) ---
    if n_puntos == 0:
        st.subheader("ğŸ¯ PASO 1: MarcÃ¡ el CENTRO (Cruce 0,0)")
    elif n_puntos == 1:
        st.subheader("â¡ï¸ PASO 2: MarcÃ¡ los 60Â° a la DERECHA (Eje X)")
    elif n_puntos == 2:
        st.subheader("â¬†ï¸ PASO 3: MarcÃ¡ los 60Â° ARRIBA (Eje Y)")
    else:
        st.subheader("âœ… CalibraciÃ³n Lista")

    if n_puntos < 3:
        # Dibujamos marcas temporales para que veas dÃ³nde hiciste clic
        img_temp = img_orig.copy()
        for p in st.session_state.puntos:
            cv2.drawMarker(img_temp, p, (0, 0, 255), cv2.MARKER_CROSS, 40, 3)

        # CAPTURA DE CLIC: Cambiamos el ID en cada paso para forzar el refresco
        id_componente = f"canvas_{n_puntos}"
        value = streamlit_image_coordinates(img_temp, key=id_componente)

        if value is not None:
            # Obtenemos las coordenadas del clic
            p_nuevo = (value["x"], value["y"])
            
            # Solo guardamos si no es igual al anterior (evita bucles infinitos)
            if n_puntos == 0 or p_nuevo != st.session_state.puntos[-1]:
                st.session_state.puntos.append(p_nuevo)
                st.rerun() # ESTO FUERZA QUE EL TEXTO CAMBIE AL INSTANTE
    else:
        # --- CÃLCULO FINAL SI YA HAY 3 PUNTOS ---
        cx, cy = st.session_state.puntos[0]
        x60_d, y60_d = st.session_state.puntos[1]
        x60_a, y60_a = st.session_state.puntos[2]

        # Escalas basadas en tu propuesta de dividir por 6
        px_10_x = np.abs(x60_d - cx) / 6
        px_10_y = np.abs(y60_a - cy) / 6

        img_res = img_orig.copy()
        # AquÃ­ dibujarÃ­amos los 4 anillos (puedes aÃ±adir la lÃ³gica de detecciÃ³n aquÃ­)
        for i in range(1, 5):
            rx = int(i * px_10_x)
            ry = int(i * px_10_y)
            cv2.ellipse(img_res, (cx, cy), (rx, ry), 0, 0, 360, (0, 255, 0), 2)
        
        st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), caption="Grilla Calibrada")
        st.success("Anillos generados cada 10Â° basados en tus marcas.")

else:
    st.info("SubÃ­ una imagen para ver la guÃ­a de pasos.")
