import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V22")
st.title("丘뒲잺 Calibraci칩n Equidistante de Precisi칩n")

img_file = st.sidebar.file_uploader("1. Subir Informe", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # --- CALIBRACI칍N POR EJES (3 PUNTOS) ---
    st.sidebar.header("游꿢 1. Ubicar el Centro (0,0)")
    cx = st.sidebar.slider("Centro X", 0, w, w // 2)
    cy = st.sidebar.slider("Centro Y", 0, h, h // 2)

    st.sidebar.header("游늺 2. Ajustar L칤mite 60춿")
    # Este slider define la distancia al 60. El programa dividir치 por 6 autom치ticamente.
    x60 = st.sidebar.slider("Posici칩n Marca 60춿 (Eje X)", cx, w, cx + 300)
    
    # Calculamos la unidad base: P칤xeles por cada 10 grados
    px_cada_10 = (x60 - cx) / 6

    st.sidebar.header("游댧 3. Par치metros de An치lisis")
    umbral = st.sidebar.slider("Sensibilidad Negros", 50, 255, 140)
    opacidad = st.sidebar.slider("Opacidad de Colores", 0.0, 1.0, 0.4)

    # --- PROCESAMIENTO ---
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    img_res = img_orig.copy()
    puntos_totales = 0

    # Dibujamos los 6 anillos (aunque calculamos solo hasta 40, dibujamos 6 para validar 60)
    for i in range(1, 7):
        r_ext = int(i * px_cada_10)
        r_int = int((i - 1) * px_cada_10)
        
        # Grosor mayor para los anillos centrales para que no se pierdan
        grosor = 3 if i <= 4 else 1
        color_linea = (0, 0, 0) # Negro puro

        # Analizar sectores (SOLO para los primeros 4 anillos: 10춿, 20춿, 30춿, 40춿)
        if i <= 4:
            for s in range(8):
                ang = s * 45
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.ellipse(mask, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, 255, -1)
                cv2.circle(mask, (cx, cy), r_int, 0, -1)
                
                area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
                area_total = np.count_nonzero(mask)
                
                if area_total > 0:
                    ocu = (area_negra / area_total) * 100
                    col, pts = None, 0
                    if ocu >= 8: col, pts = (0, 255, 255), 10
                    elif 1.2 < ocu < 8: col, pts = (255, 255, 0), 5
                    
                    if col:
                        puntos_totales += pts
                        overlay = img_res.copy()
                        cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, col, -1)
                        cv2.circle(overlay, (cx, cy), r_int, (255,255,255), -1)
                        img_res = cv2.addWeighted(overlay, opacidad, img_res, 1 - opacidad, 0)

        # Dibujar el c칤rculo NEGRO s칩lido (S칰per visible)
        cv2.circle(img_res, (cx, cy), r_ext, color_linea, grosor)
        
        # Dibujar l칤neas radiales para los sectores
        for s in range(8):
            rad = np.radians(s * 45)
            x_end = int(cx + (6 * px_cada_10) * np.cos(rad))
            y_end = int(cy + (6 * px_cada_10) * np.sin(rad))
            cv2.line(img_res, (cx, cy), (x_end, y_end), (0, 0, 0), 1)

    # Marca de Centro y Gu칤a de 60
    cv2.drawMarker(img_res, (cx, cy), (0, 0, 255), cv2.MARKER_CROSS, 40, 3)
    cv2.drawMarker(img_res, (int(cx + 6*px_cada_10), cy), (255, 0, 0), cv2.MARKER_TRIANGLE_UP, 20, 2)

    # --- SALIDA ---
    st.subheader(f"游늵 Suma: {puntos_totales} pts | Incapacidad: {round((puntos_totales/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)
