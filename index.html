import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

# Configuración inicial de memoria
if "paso" not in st.session_state:
    st.session_state.paso = 1
if "puntos" not in st.session_state:
    st.session_state.puntos = {}

st.title("⚖️ Analizador de Incapacidad")

# --- CABECERA DINÁMICA ---
# Esto es lo que NO te estaba cambiando. Ahora depende de st.session_state.paso
if st.session_state.paso == 1:
    st.header("1. Ubicá el Centro (0,0)")
elif st.session_state.paso == 2:
    st.header("2. Ubicá la marca de 60° a la DERECHA")
elif st.session_state.paso == 3:
    st.header("3. Ubicá la marca de 60° SUPERIOR")
else:
    st.header("✅ Calibración Completa")

img_file = st.sidebar.file_uploader("Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)

    # Si estamos en proceso de marcar puntos
    if st.session_state.paso <= 3:
        # Mostramos la imagen para que el usuario haga clic
        # Agregamos una 'key' única para cada paso para que el componente se resetee
        coords = streamlit_image_coordinates(img_orig, key=f"clic_paso_{st.session_state.paso}")
        
        if coords:
            st.session_state.temp_point = (coords["x"], coords["y"])
            st.write(f"Punto seleccionado: {st.session_state.temp_point}")
            
            # EL BOTÓN QUE FUERZA EL CAMBIO
            if st.button(f"Confirmar Punto {st.session_state.paso} y Continuar"):
                # Guardamos el punto en el diccionario
                st.session_state.puntos[st.session_state.paso] = st.session_state.temp_point
                # Avanzamos el paso
                st.session_state.paso += 1
                # Forzamos el reinicio de la página para que cambie el st.header
                st.rerun()
    else:
        # --- LÓGICA DE CÁLCULO (Solo cuando ya tenemos los 3 puntos) ---
        p1 = st.session_state.puntos[1] # Centro
        p2 = st.session_state.puntos[2] # 60° Derecha
        
        # Distancia para calcular los anillos (tu regla de dividir por 6)
        dist_x = np.abs(p2[0] - p1[0])
        px_cada_10 = dist_x / 6
        
        st.success(f"Calibración exitosa: {round(px_cada_10, 2)} píxeles cada 10°")
        # Aquí sigue tu código de dibujo de anillos y conteo de negros...
        
    if st.sidebar.button("Limpiar y Reiniciar"):
        st.session_state.paso = 1
        st.session_state.puntos = {}
        st.rerun()
