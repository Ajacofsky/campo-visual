import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

st.set_page_config(layout="wide", page_title="Peritaje Pro - Calibraci贸n Triaxial")
st.title("锔 Analizador de Incapacidad - Propuesta de Alta Precisi贸n")

# Explicaci贸n de por qu茅 este m茅todo es mejor
st.sidebar.info(" Este m茅todo usa 3 puntos para corregir deformaciones de la foto y filtros de solidez para ignorar c铆rculos.")

img_file = st.sidebar.file_uploader("Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file is not None:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    if "puntos" not in st.session_state: st.session_state.puntos = []

    # UI de Calibraci贸n
    if len(st.session_state.puntos) < 3:
        pasos = ["CENTRO (0,0)", "60掳 DERECHA (Eje X)", "60掳 ARRIBA (Eje Y)"]
        st.warning(f" Marc谩 el punto: {pasos[len(st.session_state.puntos)]}")
    else:
        if st.sidebar.button(" Reiniciar Calibraci贸n"):
            st.session_state.puntos = []
            st.rerun()

    coords = streamlit_image_coordinates(img_orig, key="calibrador")

    if coords and len(st.session_state.puntos) < 3:
        p = (coords["x"], coords["y"])
        if p not in st.session_state.puntos:
            st.session_state.puntos.append(p)
            st.rerun()

    if len(st.session_state.puntos) == 3:
        cx, cy = st.session_state.puntos[0]
        x60, y60_x = st.session_state.puntos[1] # Punto 60 derecha
        x60_y, y60 = st.session_state.puntos[2] # Punto 60 arriba

        # Calculamos escalas independientes para X e Y (Corrige deformaci贸n de foto)
        px_grado_x = np.sqrt((x60 - cx)**2 + (y60_x - cy)**2) / 60
        px_grado_y = np.sqrt((x60_y - cx)**2 + (y60 - cy)**2) / 60

        # PROCESAMIENTO AVANZADO DE OBJETOS
        gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
        # Filtro de contraste para resaltar negros
        gris = cv2.equalizeHist(gris)
        _, binaria = cv2.threshold(gris, 100, 255, cv2.THRESH_BINARY_INV)
        
        img_final = img_orig.copy()
        pts_totales = 0

        # Solo 4 anillos (40掳)
        for i in range(4):
            rx = (i + 1) * 10 * px_grado_x
            ry = (i + 1) * 10 * px_grado_y
            rx_in = i * 10 * px_grado_x
            ry_in = i * 10 * px_grado_y
            
            for s in range(8):
                ang = s * 45
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.ellipse(mask, (cx, cy), (int(rx), int(ry)), 0, ang, ang + 45, 255, -1)
                cv2.ellipse(mask, (cx, cy), (int(rx_in), int(ry_in)), 0, 0, 360, 0, -1)
                
                # An谩lisis de "Objetos Reales" en el sector
                sector = cv2.bitwise_and(binaria, mask)
                cnts, _ = cv2.findContours(sector, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                
                # Aqu铆 est谩 la magia: filtramos c铆rculos por solidez
                area_cuadrados = 0
                for c in cnts:
                    area = cv2.contourArea(c)
                    if area < 5: continue # Ignorar ruido
                    
                    # El cuadrado es "s贸lido", el c铆rculo vac铆o no
                    hull = cv2.convexHull(c)
                    solidez = area / cv2.contourArea(hull) if cv2.contourArea(hull) > 0 else 0
                    
                    if solidez > 0.75: # Es un bloque s贸lido (cuadrado)
                        area_cuadrados += area

                # Nueva regla de decisi贸n
                area_total = np.count_nonzero(mask)
                if area_total > 0:
                    ocupacion = (area_cuadrados / area_total) * 100
                    color = None
                    puntos = 0
                    
                    if ocupacion > 8: # Masa cr铆tica de negros
                        color = (0, 255, 255) # Amarillo (10 pts)
                        puntos = 10
                    elif 1.2 < ocupacion <= 8:
                        color = (255, 255, 0) # Celeste (5 pts)
                        puntos = 5
                    
                    if color:
                        pts_totales += puntos
                        overlay = img_final.copy()
                        cv2.ellipse(overlay, (cx, cy), (int(rx), int(ry)), 0, ang, ang + 45, color, -1)
                        cv2.ellipse(overlay, (cx, cy), (int(rx_in), int(ry_in)), 0, 0, 360, (255,255,255), -1)
                        img_final = cv2.addWeighted(overlay, 0.4, img_final, 0.6, 0)

        # Dibujar gu铆as de calibraci贸n
        cv2.drawMarker(img_final, (cx, cy), (255, 0, 0), cv2.MARKER_CROSS, 30, 2)
        cv2.line(img_final, (cx, cy), (x60, y60_x), (0, 255, 0), 2)
        cv2.line(img_final, (cx, cy), (x60_y, y60), (0, 255, 0), 2)

        st.markdown(f"##  Resultado: {pts_totales} puntos")
        st.image(cv2.cvtColor(img_final, cv2.COLOR_BGR2RGB), use_container_width=True)
    else:
        st.image(img_orig, caption="Esperando calibraci贸n de 3 puntos...", use_container_width=True)
