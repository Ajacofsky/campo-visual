import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V25 - PRECISI칍N")
st.title("丘뒲잺 Calibraci칩n de Anillos Equidistantes")

img_file = st.sidebar.file_uploader("Subir Informe", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # --- CONTROLES DE CALIBRACI칍N ---
    st.sidebar.header("游꿢 1. Ubicar el Centro (0,0)")
    cx = st.sidebar.slider("Centro X", 0, w, w // 2)
    cy = st.sidebar.slider("Centro Y", 0, h, h // 2)

    st.sidebar.header("游늺 2. Anclar a Marca 60춿")
    # Este es el punto maestro que define todos los dem치s anillos
    x60 = st.sidebar.slider("Alinear con Marca 60 del Eje X", cx, w, cx + 250)
    
    # C츼LCULO DE LA UNIDAD EQUIDISTANTE (pasos de 10 grados)
    distancia_al_60 = x60 - cx
    px_cada_10 = distancia_al_60 / 6

    st.sidebar.header("游댧 3. Detecci칩n")
    umbral = st.sidebar.slider("Sensibilidad Negros", 50, 255, 140)

    # --- MOTOR DE PROCESAMIENTO ---
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    img_res = img_orig.copy()
    puntos_totales = 0

    # PASO 1: Pintar los sectores de color (Amarillo/Celeste)
    for i in range(1, 5): # Solo anillos del 10 al 40
        r_ext = int(i * px_cada_10)
        r_int = int((i - 1) * px_cada_10)
        
        for s in range(8):
            ang = s * 45
            mask = np.zeros((h, w), dtype=np.uint8)
            cv2.ellipse(mask, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, 255, -1)
            cv2.circle(mask, (cx, cy), r_int, 0, -1)
            
            area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
            area_total = np.count_nonzero(mask)
            
            if area_total > 0:
                ocu = (area_negra / area_total) * 100
                if ocu >= 8:
                    color, pts = (0, 255, 255), 10
                    puntos_totales += pts
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, color, -1)
                    img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)
                elif 1.2 < ocu < 8:
                    color, pts = (255, 255, 0), 5
                    puntos_totales += pts
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, color, -1)
                    img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)

    # PASO 2: Dibujar la Grilla Negra (AL FINAL para que sea lo m치s visible)
    # Dibujamos los 6 anillos para que veas la escala completa hasta 60
    for i in range(1, 7):
        radio = int(i * px_cada_10)
        # NEGRO ABSOLUTO (0,0,0) y GROSOR 4 (Muy fuerte)
        cv2.circle(img_res, (cx, cy), radio, (0, 0, 0), 4)
        
        # Divisiones de sectores (L칤neas radiales negras)
        for s in range(8):
            rad = np.radians(s * 45)
            x_line = int(cx + (6 * px_cada_10) * np.cos(rad))
            y_line = int(cy + (6 * px_cada_10) * np.sin(rad))
            cv2.line(img_res, (cx, cy), (x_line, y_line), (0, 0, 0), 2)

    # PASO 3: Ejes Cartesianos y Marca de Gu칤a
    cv2.line(img_res, (cx, 0), (cx, h), (0, 0, 0), 2) # Eje Y negro
    cv2.line(img_res, (0, cy), (w, cy), (0, 0, 0), 2) # Eje X negro
    cv2.drawMarker(img_res, (x60, cy), (0, 0, 255), cv2.MARKER_TRIANGLE_DOWN, 30, 4) # Flecha roja en 60

    # --- RESULTADOS ---
    st.subheader(f"游늵 Suma: {puntos_totales} pts | Incapacidad: {round((puntos_totales/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)
    st.success(f"Configuraci칩n: Anillos equidistantes cada {round(px_cada_10, 2)} p칤xeles.")

else:
    st.info("Sub칤 la imagen para aplicar la grilla reforzada.")
