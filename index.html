import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V24")

# --- INTERFAZ ---
st.sidebar.title("游늺 Calibraci칩n de Precisi칩n")
img_file = st.sidebar.file_uploader("Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # 1. UBICACI칍N DEL CENTRO
    st.sidebar.markdown("### 1. Centro (0,0)")
    cx = st.sidebar.slider("Eje X Central", 0, w, w // 2)
    cy = st.sidebar.slider("Eje Y Central", 0, h, h // 2)

    # 2. ANCLAJE AL ANILLO EXTERNO (60춿)
    st.sidebar.markdown("### 2. Ancla de 60춿")
    # Movemos este slider hasta que el marcador coincida con el '60' del papel
    x60 = st.sidebar.slider("Ubicar sobre marca 60춿", cx, w, cx + 200)
    
    # MATEM츼TICA: Distancia Centro-60 dividida 6 = Distancia cada 10춿
    distancia_60 = x60 - cx
    px_cada_10 = distancia_60 / 6

    # 3. SENSIBILIDAD
    umbral = st.sidebar.slider("Sensibilidad Negros", 50, 255, 140)

    # --- PROCESAMIENTO GR츼FICO ---
    img_res = img_orig.copy()
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    puntos_totales = 0

    # Dibujamos 6 anillos (del 10 al 60) para asegurar coincidencia total
    for i in range(1, 7):
        # El radio es exactamente un m칰ltiplo de la sexta parte de la distancia al 60
        radio_ext = int(i * px_cada_10)
        radio_int = int((i - 1) * px_cada_10)
        
        # DIBUJO DE ANILLO: Negro puro, grosor 3 (M치xima visibilidad)
        cv2.circle(img_res, (cx, cy), radio_ext, (0, 0, 0), 3)

        # EVALUACI칍N (Solo anillos 1, 2, 3 y 4 seg칰n tu protocolo de 40춿)
        if i <= 4:
            for s in range(8):
                ang = s * 45
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.ellipse(mask, (cx, cy), (radio_ext, radio_ext), 0, ang, ang + 45, 255, -1)
                cv2.circle(mask, (cx, cy), radio_int, 0, -1)
                
                area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
                area_total = np.count_nonzero(mask)
                
                if area_total > 0:
                    ocupacion = (area_negra / area_total) * 100
                    color = None
                    if ocupacion >= 8: # Amarillo
                        color, pts = (0, 255, 255), 10
                    elif 1.2 < ocupacion < 8: # Celeste
                        color, pts = (255, 255, 0), 5
                    
                    if color:
                        puntos_totales += pts
                        overlay = img_res.copy()
                        cv2.ellipse(overlay, (cx, cy), (radio_ext, radio_ext), 0, ang, ang + 45, color, -1)
                        img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)

    # DIBUJO DE EJES NEGROS
    cv2.line(img_res, (cx, 0), (cx, h), (0, 0, 0), 2)
    cv2.line(img_res, (0, cy), (w, cy), (0, 0, 0), 2)

    # INDICADOR DE CONTROL EN 60춿
    cv2.drawMarker(img_res, (x60, cy), (0, 0, 255), cv2.MARKER_TRIANGLE_DOWN, 25, 4)

    # --- SALIDA ---
    st.subheader(f"游늵 Suma: {puntos_totales} pts | Incapacidad: {round((puntos_totales/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)
    st.success(f"Escala: 10춿 equivalen a {round(px_cada_10, 2)} p칤xeles.")

else:
    st.info("Sub칤 la imagen para iniciar la divisi칩n equidistante.")
