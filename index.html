import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V18")
st.title("锔 Analizador de Incapacidad - Calibraci贸n Garantizada")

# --- CARGA DE ARCHIVO ---
img_file = st.sidebar.file_uploader("1. Sub铆 el Informe", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    st.sidebar.markdown("---")
    st.sidebar.header(" Ajuste del Centro")
    # Sliders para mover el centro pixel por pixel
    cx = st.sidebar.slider("Posici贸n Horizontal (X)", 0, w, w // 2)
    cy = st.sidebar.slider("Posici贸n Vertical (Y)", 0, h, h // 2)

    st.sidebar.markdown("---")
    st.sidebar.header(" Ajuste de Escala (Marca 60掳)")
    # Slider para mover la marca de 60 grados
    x60 = st.sidebar.slider("Ubicaci贸n marca 60掳", 0, w, cx + 100)

    # --- LGICA DE CLCULO (Tu regla de 6 partes) ---
    dist_60 = np.abs(x60 - cx)
    px_cada_10 = dist_60 / 6

    # --- PROCESAMIENTO DE IMAGEN ---
    umbral = st.sidebar.slider("Sensibilidad de Cuadrados Negros", 50, 255, 140)
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    # Limpieza de ruido
    kernel = np.ones((3,3), np.uint8)
    binaria = cv2.morphologyEx(binaria, cv2.MORPH_OPEN, kernel)

    img_res = img_orig.copy()
    total_puntos = 0

    # DIBUJO DE LOS 4 ANILLOS (10, 20, 30, 40 grados)
    for i in range(1, 5):
        r_ext = int(i * px_cada_10)
        r_int = int((i-1) * px_por_10_grados if i > 1 else 0) # Error corregido de variable
        
        # Dibujar anillo gu铆a
        cv2.circle(img_res, (cx, cy), r_ext, (200, 200, 200), 1)
        
        # Analizar los 8 sectores por anillo
        for s in range(8):
            ang = s * 45
            mask = np.zeros((h, w), dtype=np.uint8)
            cv2.ellipse(mask, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, 255, -1)
            if i > 1:
                cv2.circle(mask, (cx, cy), int((i-1) * px_cada_10), 0, -1)
            
            # Conteo de masa negra
            area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
            area_total = np.count_nonzero(mask)
            
            if area_total > 0:
                ocupacion = (area_negra / area_total) * 100
                color, pts = None, 0
                
                # Regla: Amarillo (>70% de cuadraditos) | Celeste (<70%)
                if ocupacion >= 8: # Umbral de masa s贸lida
                    color, pts = (0, 255, 255), 10
                elif 1.2 < ocupacion < 8:
                    color, pts = (255, 255, 0), 5
                
                if color:
                    total_puntos += pts
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, color, -1)
                    img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)

    # Marcas de calibraci贸n visual
    cv2.drawMarker(img_res, (cx, cy), (255, 0, 0), cv2.MARKER_CROSS, 30, 2) # Centro Azul
    cv2.drawMarker(img_res, (x60, cy), (0, 0, 255), cv2.MARKER_TACK, 20, 2) # Marca 60 Roja

    # --- MOSTRAR RESULTADOS ---
    st.subheader(f" Suma: {total_puntos} pts | Incapacidad: {round((total_puntos/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)
    
    st.write(" **Instrucciones:**")
    st.write("1. Mov茅 los sliders de la izquierda para que la **Cruz Azul** quede en el centro.")
    st.write("2. Mov茅 el slider de escala hasta que el **Punto Rojo** toque la marca de 60掳 de tu informe.")
    st.write("3. Los anillos se ajustar谩n solos y calcular谩n la incapacidad.")

else:
    st.info("Sub铆 el archivo para ver los controles de calibraci贸n.")
