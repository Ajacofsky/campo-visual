import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

st.set_page_config(layout="wide", page_title="Peritaje Pro - CalibraciÃ³n")
st.title("âš–ï¸ Analizador de Incapacidad - CalibraciÃ³n de Escala")

img_file = st.sidebar.file_uploader("Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file is not None:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    st.sidebar.markdown("### ðŸ› ï¸ Pasos de CalibraciÃ³n")
    paso = st.sidebar.radio("SeleccionÃ¡ quÃ© marcar:", ["1. Centro (0,0)", "2. Marca de 60Â° Derecha"])
    umbral = st.sidebar.slider("Sensibilidad de Negros", 50, 255, 140)

    # Inicializar coordenadas en sesiÃ³n
    if "p_centro" not in st.session_state: st.session_state.p_centro = (w//2, h//2)
    if "p_60" not in st.session_state: st.session_state.p_60 = (w//2 + 100, h//2)

    st.write(f"### HacÃ© clic para marcar: {paso}")
    coords = streamlit_image_coordinates(img_orig, key="calibrador")

    if coords:
        if paso == "1. Centro (0,0)":
            st.session_state.p_centro = (coords["x"], coords["y"])
        else:
            st.session_state.p_60 = (coords["x"], coords["y"])

    cx, cy = st.session_state.p_centro
    x60, y60 = st.session_state.p_60

    # CÃLCULO DE ESCALA Y ROTACIÃ“N
    dist_60 = np.sqrt((x60 - cx)**2 + (y60 - cy)**2)
    px_por_grado = dist_60 / 60
    angulo_rad = np.arctan2(y60 - cy, x60 - cx)
    angulo_deg = np.degrees(angulo_rad)

    # --- PROCESAMIENTO ---
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    kernel = np.ones((3,3), np.uint8)
    binaria = cv2.morphologyEx(binaria, cv2.MORPH_OPEN, kernel)

    img_final = img_orig.copy()
    total_puntos = 0

    # Analizamos 5 anillos (10Â° a 50Â°)
    for i in range(5): 
        r_ext = (i + 1) * 10 * px_por_grado
        r_int = i * 10 * px_por_grado
        
        for s in range(8):
            # Ajustamos el Ã¡ngulo de los sectores segÃºn la inclinaciÃ³n detectada
            offset_angulo = angulo_deg
            a_inicio = s * 45 + offset_angulo
            
            mask = np.zeros((h, w), dtype=np.uint8)
            cv2.ellipse(mask, (cx, cy), (int(r_ext), int(r_ext)), 0, a_inicio, a_inicio + 45, 255, -1)
            cv2.circle(mask, (cx, cy), int(r_int), 0, -1)
            
            sector_negro = cv2.bitwise_and(binaria, mask)
            area_negra = np.count_nonzero(sector_negro)
            area_total = np.count_nonzero(mask)
            
            if area_total > 0:
                ocupacion = (area_negra / area_total) * 100
                color = None
                puntos = 0
                
                # LÃ“GICA DE COLORES PEDIDA
                if ocupacion >= 10: # Ajustado por densidad de masa
                    color = (0, 255, 255) # AMARILLO (>70% de cuadraditos) -> 10 pts
                    puntos = 10
                elif 1.5 < ocupacion < 10:
                    color = (255, 255, 0) # CELESTE (<70% de cuadraditos) -> 5 pts
                    puntos = 5
                
                if color:
                    total_puntos += puntos
                    overlay = img_final.copy()
                    cv2.ellipse(overlay, (cx, cy), (int(r_ext), int(r_ext)), 0, a_inicio, a_inicio + 45, color, -1)
                    cv2.circle(overlay, (cx, cy), int(r_int), (255,255,255), -1)
                    img_final = cv2.addWeighted(overlay, 0.4, img_final, 0.6, 0)

    # Dibujar indicadores de calibraciÃ³n
    cv2.line(img_final, (cx, cy), (x60, y60), (255, 0, 0), 2)
    cv2.drawMarker(img_final, (cx, cy), (255, 0, 0), cv2.MARKER_CROSS, 20, 2)
    
    img_rgb = cv2.cvtColor(img_final, cv2.COLOR_BGR2RGB)
    st.markdown(f"## ðŸ“Š Suma: {total_puntos} pts | Escala: {round(px_por_grado, 2)} px/Â°")
    st.image(img_rgb, use_container_width=True)

else:
    st.info("SubÃ­ la imagen para calibrar escala y rotaciÃ³n.")
