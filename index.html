import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V28")
st.title("âš–ï¸ CalibraciÃ³n de Grilla Roja Equidistante")

img_file = st.sidebar.file_uploader("Subir Informe", type=['jpg', 'png', 'jpeg'])

if img_file:
    # Cargar imagen original
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # --- CONTROLES DE POSICIÃ“N ---
    st.sidebar.subheader("ðŸŽ¯ 1. Ubicar Centro")
    cx = st.sidebar.slider("Centro X (Horizontal)", 0, w, w // 2)
    cy = st.sidebar.slider("Centro Y (Vertical)", 0, h, h // 2)

    st.sidebar.subheader("ðŸ“ 2. Definir Escala")
    # Este slider debe moverse hasta la marca de 60Â° del papel
    x60 = st.sidebar.slider("Alinear con Marca 60Â°", cx, w, cx + 200)
    
    # CÃLCULO DE EQUIDISTANCIA: 
    # La distancia total al 60 se divide por 6. Cada anillo i es i * unidad.
    px_unidad = (x60 - cx) / 6.0

    st.sidebar.subheader("ðŸ”¬ 3. DetecciÃ³n")
    umbral = st.sidebar.slider("Umbral de Negros", 50, 255, 140)

    # --- PROCESAMIENTO ---
    img_res = img_orig.copy()
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    puntos_totales = 0

    # 1. PRIMERO: Analizar y pintar los sectores (10Â° a 40Â°)
    for i in range(1, 5):
        r_ext = int(i * px_unidad)
        r_int = int((i - 1) * px_unidad)
        
        for s in range(8):
            ang = s * 45
            mask = np.zeros((h, w), dtype=np.uint8)
            cv2.ellipse(mask, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, 255, -1)
            cv2.circle(mask, (cx, cy), r_int, 0, -1)
            
            area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
            area_total = np.count_nonzero(mask)
            
            if area_total > 0:
                ocupacion = (area_negra / area_total) * 100
                if ocupacion >= 8: # Amarillo
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, (0, 255, 255), -1)
                    img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)
                    puntos_totales += 10
                elif 1.2 < ocupacion < 8: # Celeste
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang, ang + 45, (255, 255, 0), -1)
                    img_res = cv2.addWeighted(overlay, 0.4, img_res, 0.6, 0)
                    puntos_totales += 5

    # 2. SEGUNDO: Dibujar la GRILLA ROJA (Encima de todo para que se vea)
    color_rojo = (0, 0, 255) # BGR: Rojo puro
    
    # Dibujamos los 6 anillos (10, 20, 30, 40, 50, 60)
    for i in range(1, 7):
        radio = int(i * px_unidad)
        # Anillos rojos gruesos (5px)
        cv2.circle(img_res, (cx, cy), radio, color_rojo, 5)
        
        # LÃ­neas de los ejes tambiÃ©n en rojo para que coincidan con las marcas
        for s in range(8):
            rad = np.radians(s * 45)
            x_end = int(cx + (6 * px_unidad) * np.cos(rad))
            y_end = int(cy + (6 * px_unidad) * np.sin(rad))
            cv2.line(img_res, (cx, cy), (x_end, y_end), color_rojo, 2)

    # 3. MARCAS DE CONTROL FINAL
    # Flecha guÃ­a en la posiciÃ³n 60
    cv2.drawMarker(img_res, (x60, cy), (0, 0, 150), cv2.MARKER_TRIANGLE_DOWN, 30, 5)

    # --- MOSTRAR ---
    st.subheader(f"ðŸ“Š Suma: {puntos_totales} pts | Incapacidad: {round((puntos_totales/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)
    
    st.markdown(f"""
    **Instrucciones:**
    1. AjustÃ¡ **X e Y** al centro del informe.
    2. MovÃ© **'Alinear con Marca 60Â°'** hasta que el Ãºltimo anillo rojo pise el '60' del papel.
    3. Los anillos internos (10, 20, 30, 40) se ajustarÃ¡n **solos** por equidistancia.
    """)

else:
    st.info("SubÃ­ el informe para ver la grilla roja equidistante.")
