import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

st.set_page_config(layout="wide", page_title="Peritaje Pro - Calibraci√≥n 60¬∞")
st.title("‚öñÔ∏è Analizador de Incapacidad - Divisi√≥n por Escala 60¬∞")

img_file = st.sidebar.file_uploader("1. Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file is not None:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # --- CALIBRACI√ìN BASADA EN TU PROPUESTA ---
    if "puntos" not in st.session_state:
        st.session_state.puntos = [] 

    if len(st.session_state.puntos) < 2:
        instruccion = "Hac√© clic en el CENTRO (0,0)" if not st.session_state.puntos else "Hac√© clic en la marca de 60¬∞ (Eje X)"
        st.info(f"üìç {instruccion}")
    else:
        if st.sidebar.button("üîÑ Nueva Calibraci√≥n"):
            st.session_state.puntos = []
            st.rerun()

    coords = streamlit_image_coordinates(img_orig, key="calibrador")

    if coords and len(st.session_state.puntos) < 2:
        nuevo_punto = (coords["x"], coords["y"])
        if nuevo_punto not in st.session_state.puntos:
            st.session_state.puntos.append(nuevo_punto)
            st.rerun()

    if len(st.session_state.puntos) == 2:
        cx, cy = st.session_state.puntos[0]
        x60, y60 = st.session_state.puntos[1]
        
        # L√≥gica de divisi√≥n: 60 grados / 6 partes = 10 grados por cada divisi√≥n
        dist_total_60 = np.sqrt((x60 - cx)**2 + (y60 - cy)**2)
        px_por_10_grados = dist_total_60 / 6
        
        # Ajuste de rotaci√≥n autom√°tica basado en la l√≠nea de 60¬∞
        angulo_rotacion = np.degrees(np.arctan2(y60 - cy, x60 - cx))

        umbral = st.sidebar.slider("Sensibilidad de Negros", 50, 255, 145)
        gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
        _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
        
        # Filtro morfol√≥gico para solo detectar cuadrados s√≥lidos
        kernel = np.ones((3,3), np.uint8)
        binaria = cv2.morphologyEx(binaria, cv2.MORPH_OPEN, kernel)

        img_final = img_orig.copy()
        puntos_totales = 0

        # SOLO 4 ANILLOS (10¬∞, 20¬∞, 30¬∞, 40¬∞)
        for i in range(4):
            r_ext = (i + 1) * px_por_10_grados
            r_int = i * px_por_10_grados
            
            for s in range(8): # 8 sectores de 45¬∞
                a_inicio = s * 45 + angulo_rotacion
                
                mask = np.zeros((h, w), dtype=np.uint8)
                cv2.ellipse(mask, (cx, cy), (int(r_ext), int(r_ext)), 0, a_inicio, a_inicio + 45, 255, -1)
                cv2.circle(mask, (cx, cy), int(r_int), 0, -1) # Limpiar interior
                
                # Evaluaci√≥n de cuadraditos
                area_cuadrados = np.count_nonzero(cv2.bitwise_and(binaria, mask))
                area_total = np.count_nonzero(mask)
                
                if area_total > 0:
                    ocupacion = (area_cuadrados / area_total) * 100
                    color = None
                    pts = 0
                    
                    # REGLA SOLICITADA: Amarillo > 70% | Celeste < 70%
                    if ocupacion >= 10: # Representa alta densidad de masa s√≥lida
                        color = (0, 255, 255) # Amarillo (BGR)
                        pts = 10
                    elif 1.5 < ocupacion < 10:
                        color = (255, 255, 0) # Celeste (BGR)
                        pts = 5
                    
                    if color:
                        puntos_totales += pts
                        overlay = img_final.copy()
                        cv2.ellipse(overlay, (cx, cy), (int(r_ext), int(r_ext)), 0, a_inicio, a_inicio + 45, color, -1)
                        cv2.circle(overlay, (cx, cy), int(r_int), (255,255,255), -1) # Evitar pintar centro
                        img_final = cv2.addWeighted(overlay, 0.4, img_final, 0.6, 0)

            # Dibujar anillos conc√©ntricos grises
            cv2.circle(img_final, (cx, cy), int(r_ext), (200, 200, 200), 1)

        # Dibujar marca de 60¬∞ y centro
        cv2.line(img_final, (cx, cy), (x60, y60), (255, 0, 0), 2)
        cv2.drawMarker(img_final, (cx, cy), (255, 0, 0), cv2.MARKER_CROSS, 20, 2)

        incapacidad = (puntos_totales / 320) * 100 # M√°ximo te√≥rico 32 sectores * 10 pts
        
        st.success("‚úÖ Escala calibrada por divisi√≥n de 60¬∞")
        st.markdown(f"## üìä Suma: {puntos_totales} pts | Incapacidad Visual: {round(incapacidad, 1)}%")
        st.image(cv2.cvtColor(img_final, cv2.COLOR_BGR2RGB), use_container_width=True)
    else:
        st.image(img_orig, caption="Por favor, marca el centro y la marca de 60¬∞", use_container_width=True)

else:
    st.info("Sube la imagen para calibrar usando la divisi√≥n de 6 partes sobre el eje X.")
