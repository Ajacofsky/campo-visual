import streamlit as st
import cv2
import numpy as np

st.set_page_config(layout="wide", page_title="Peritaje Pro V21")
st.title("丘뒲잺 Analizador de Incapacidad - Grilla de Alto Contraste")

img_file = st.sidebar.file_uploader("1. Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    h, w = img_orig.shape[:2]

    # --- CONTROLES DE PRECISI칍N ---
    st.sidebar.subheader("游꿢 Ajuste de Posici칩n")
    cx = st.sidebar.slider("Centro Horizontal (X)", 0, w, w // 2)
    cy = st.sidebar.slider("Centro Vertical (Y)", 0, h, h // 2)
    
    st.sidebar.subheader("游늺 Ajuste de Escala")
    px_cada_10 = st.sidebar.slider("Tama침o Grilla (Pixeles/10춿)", 10, 150, 55)
    
    st.sidebar.subheader("游댧 Detecci칩n y Color")
    umbral = st.sidebar.slider("Sensibilidad de Negros", 50, 255, 145)
    opacidad = st.sidebar.slider("Intensidad de Color (Resaltado)", 0.1, 1.0, 0.4)

    # --- PROCESAMIENTO ---
    gris = cv2.cvtColor(img_orig, cv2.COLOR_BGR2GRAY)
    _, binaria = cv2.threshold(gris, umbral, 255, cv2.THRESH_BINARY_INV)
    
    img_res = img_orig.copy()
    puntos_totales = 0

    # Dibujamos 4 anillos (10춿, 20춿, 30춿, 40춿)
    for i in range(1, 5):
        r_ext = i * px_cada_10
        r_int = (i - 1) * px_cada_10
        
        for s in range(8):
            ang_deg = s * 45
            ang_rad = np.radians(ang_deg)
            
            # M치scara para an치lisis
            mask = np.zeros((h, w), dtype=np.uint8)
            cv2.ellipse(mask, (cx, cy), (r_ext, r_ext), 0, ang_deg, ang_deg + 45, 255, -1)
            cv2.circle(mask, (cx, cy), int(r_int), 0, -1)
            
            # Conteo de masa s칩lida
            area_negra = np.count_nonzero(cv2.bitwise_and(binaria, mask))
            area_total = np.count_nonzero(mask)
            
            if area_total > 0:
                ocupacion = (area_negra / area_total) * 100
                color, pts = None, 0
                
                if ocupacion >= 8: # Cuadrado s칩lido (Amarillo)
                    color, pts = (0, 255, 255), 10 
                elif 1.2 < ocupacion < 8: # Punto o borde (Celeste)
                    color, pts = (255, 255, 0), 5
                
                if color:
                    puntos_totales += pts
                    overlay = img_res.copy()
                    cv2.ellipse(overlay, (cx, cy), (r_ext, r_ext), 0, ang_deg, ang_deg + 45, color, -1)
                    cv2.circle(overlay, (cx, cy), int(r_int), (255,255,255), -1)
                    img_res = cv2.addWeighted(overlay, opacidad, img_res, 1 - opacidad, 0)

            # --- DIBUJAR L칈NEAS RADIALES NEGRAS ---
            x_fin = int(cx + r_ext * np.cos(ang_rad))
            y_fin = int(cy + r_ext * np.sin(ang_rad))
            cv2.line(img_res, (cx, cy), (x_fin, y_fin), (0, 0, 0), 2)

        # --- DIBUJAR ANILLOS NEGROS GRUESOS ---
        cv2.circle(img_res, (cx, cy), int(r_ext), (0, 0, 0), 3) # Grosor 3 para m치xima visibilidad

    # Centro de mira reforzado
    cv2.drawMarker(img_res, (cx, cy), (0, 0, 255), cv2.MARKER_CROSS, 60, 3)

    # --- INTERFAZ DE RESULTADOS ---
    st.subheader(f"游늵 Suma: {puntos_totales} pts | Incapacidad: {round((puntos_totales/320)*100, 1)}%")
    st.image(cv2.cvtColor(img_res, cv2.COLOR_BGR2RGB), use_container_width=True)

else:
    st.info("Sub칤 la imagen para ver la grilla de alto contraste.")
