import streamlit as st
import cv2
import numpy as np
from streamlit_image_coordinates import streamlit_image_coordinates

st.set_page_config(layout="wide", page_title="Peritaje Pro - CalibraciÃ³n")
st.title("âš–ï¸ CalibraciÃ³n de 3 Puntos")

img_file = st.sidebar.file_uploader("Subir Campo Visual", type=['jpg', 'png', 'jpeg'])

if img_file is not None:
    file_bytes = np.asarray(bytearray(img_file.read()), dtype=np.uint8)
    img_orig = cv2.imdecode(file_bytes, 1)
    
    if "puntos" not in st.session_state:
        st.session_state.puntos = []

    # UI de Instrucciones
    pasos = ["CENTRO (0,0)", "60Â° DERECHA (Eje X)", "60Â° ARRIBA (Eje Y)"]
    
    if len(st.session_state.puntos) < 3:
        idx = len(st.session_state.puntos)
        st.info(f"ğŸ“ PASO {idx + 1}: MarcÃ¡ el {pasos[idx]}")
    else:
        if st.sidebar.button("ğŸ”„ Reiniciar CalibraciÃ³n"):
            st.session_state.puntos = []
            st.rerun()

    # --- DIBUJAR PUNTOS PREVIOS PARA REFERENCIA ---
    img_previa = img_orig.copy()
    for p in st.session_state.puntos:
        cv2.circle(img_previa, p, 10, (0, 0, 255), -1) # CÃ­rculo rojo en puntos ya marcados

    # El truco: La 'key' cambia segÃºn cuÃ¡ntos puntos llevamos (ej: 'cal_0', 'cal_1'...)
    # Esto resetea el componente y permite capturar el siguiente clic.
    key_actual = f"calibrador_{len(st.session_state.puntos)}"
    
    coords = streamlit_image_coordinates(img_previa, key=key_actual)

    if coords:
        p_nuevo = (coords["x"], coords["y"])
        # Solo agregamos si no es el Ãºltimo punto (evita rebotes)
        if len(st.session_state.puntos) == 0 or p_nuevo != st.session_state.puntos[-1]:
            st.session_state.puntos.append(p_nuevo)
            st.rerun()

    # --- PROCESAMIENTO FINAL ---
    if len(st.session_state.puntos) == 3:
        st.success("âœ… Â¡CalibraciÃ³n completa! Procesando resultados...")
        
        cx, cy = st.session_state.puntos[0]
        x60_der, y60_der = st.session_state.puntos[1]
        x60_arr, y60_arr = st.session_state.puntos[2]

        # Escalas independientes (Corrige deformaciÃ³n)
        px_grado_x = np.abs(x60_der - cx) / 60
        px_grado_y = np.abs(y60_arr - cy) / 60

        # (AquÃ­ sigue el resto de la lÃ³gica de detecciÃ³n de cuadrados...)
        # ... [El cÃ³digo de anÃ¡lisis de solidez se mantiene igual] ...
        st.write(f"Escala X: {round(px_grado_x, 2)} | Escala Y: {round(px_grado_y, 2)}")

else:
    st.info("SubÃ­ la imagen para empezar.")
